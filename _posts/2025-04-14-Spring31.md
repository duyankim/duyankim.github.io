---
layout: post
author: "Yan"
catalog: true
subtitle: "WebFlux를 곁들인"
header-img: "img/header/spring.jpg"
title: "동기냐 비동기냐 그것이 문제로다"
date: 2025-04-14 11:40:08 +0000
categories:
  - Spring
tags:
  - Spring
  - WebFlux
  - Asnc
comments: true
---

# 동기(Synchronous) 처리

- 개념: 클라이언트 요청이 들어오면, 해당 요청을 처리하는 동안 **쓰레드가 작업을 마칠 때까지 대기**한다. 결과가 나올 때까지 다른 작업은 못한다.
- **Spring MVC (Servlet 기반)** 같은 전통적인 웹 프레임워크가 동기처리에 해당됨
- 작동방식 : 요청 → 컨트롤러 → 서비스 → DAO → 응답 (이 모든 과정이 한 쓰레드에서 순차적으로 실행됨)
- 장점:
  - 구조가 단순하고 디버깅이 쉽다.
  - 기존 스프링 생태계와 연동이 잘 된다 (ex. Spring Security, AOP 등)
- 단점:
  - I/O 작업(예: DB, 외부 API 호출 등)이 느리면 쓰레드가 블로킹되어 서버 자원이 낭비됨.
  - 많은 요청이 동시에 들어오면 쓰레드 수가 급증해서 성능이 급격히 저하될 수 있음.
 
# 비동기(Asynchronous) 처리

- 요청을 받았을 때, I/O 등 시간이 오래 걸리는 작업은 다른 작업으로 미뤄두고, 쓰레드는 즉시 반환되어 다른 요청을 처리할 수 있도록 한다.
- **Spring WebFlux (Reactor 기반)**가 대표적인 비동기 논블로킹 방식
- 작동 방식: 요청 → Mono/Flux 기반의 논블로킹 처리 → 이벤트 발생 시 응답 반환
- 장점:
  - 적은 수의 쓰레드로도 많은 요청을 동시에 처리 가능 → 높은 확장성(Scalability)
  - 특히 외부 API 호출, DB I/O 등 네트워크 병목이 많은 서비스에 적합
- 단점:
  - 콜백 지옥 혹은 복잡한 흐름 제어(이를 해결하기 위한 연산자 학습 필요)
  - 기존 라이브러리와의 호환성 문제 (블로킹 API 사용 금지 등)
  - 디버깅이 어렵고 StackTrace가 끊어져서 추적이 힘듬\

## Webflux의 동작 방식

1. 요청이 `Mono`스트림으로 만들어지고
2. 그 스트림 위에 각종 변환 연산자 `map`, `flatMap`가 체인으로 연결되고
3. 응답이 올 때 그 체인에 따라 처리되므로, 중간상태를 따로 저장하지 않아도 요청-응답 맥락이 이어지는 구조


요청과 응답은 `Mono`나 `Flux`라는 리액티브 타입을 통해 흐름이 계속 이어져있고,  
그 흐름 안에 있는 람다나 콜백 체인 (then, flapMap, map 등)을 통해 context를 유지하고 있다.

### 예제

```java
public Mono<String> getUserInfo(String userId) {
    return webClient.get()
        .uri("http://external-api.com/user/" + userId)
        .retrieve()
        .bodyToMono(String.class)
        .map(response -> {
            // 이 response는 바로 위에서 요청한 userId에 대한 결과
            log.info("userId: {}, response: {}", userId, response);
            return "유저 정보: " + response;
        });
}
```
